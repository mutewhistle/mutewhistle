use grin_wallet_api as api;
use grin_wallet_config as config;
use grin_wallet_controller::Error;
use grin_wallet_controller::ErrorKind;
use grin_wallet_impls as impls;
use grin_wallet_libwallet as libwallet;
use grin_wallet_util::grin_core::global::ChainTypes;
use grin_wallet_util::grin_keychain as keychain;
use grin_wallet_util::grin_util as util;

use keychain::ExtKeychain;
use libwallet::proof::proofaddress::ProvableAddress;

use std::sync::Arc;
use util::{Mutex, ZeroingString};

use api::Owner;
use config::parse_node_address_string;
use config::WalletConfig;
use grin_wallet_util::grin_core::global;
use impls::{DefaultLCProvider, DefaultWalletImpl, HTTPNodeClient};
use libwallet::WalletInst;
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Clone)]
struct Config {
    data_file_dir: String,
    check_node_api_http_addr: String,
    chain: String,
    account: Option<String>,
}

type Wallet = Arc<
    Mutex<
        Box<
            dyn WalletInst<
                'static,
                DefaultLCProvider<'static, HTTPNodeClient, ExtKeychain>,
                HTTPNodeClient,
                ExtKeychain,
            >,
        >,
    >,
>;

// impl Config {
//     fn from_str(json: &str) -> Result<Self, Error> {
//         serde_json::from_str::<Config>(json)
//             .map_err(|e| Error::from(ErrorKind::ConfigCannotBeParsed(e.to_string())))
//     }
// }

fn main() {
    global::set_local_chain_type(global::ChainTypes::AutomatedTesting);

    let wallet_config = WalletConfig::default();

    // A NodeClient must first be created to handle communication between
    // the wallet and the node.
    let node_list = parse_node_address_string(wallet_config.check_node_api_http_addr.clone());
    let node_client = HTTPNodeClient::new(node_list, None).unwrap();

    // impls::DefaultWalletImpl is provided for convenience in instantiating the wallet
    // It contains the LMDBBackend, DefaultLCProvider (lifecycle) and ExtKeychain used
    // by the reference wallet implementation.
    // These traits can be replaced with alternative implementations if desired

    let mut wallet =
        Box::new(DefaultWalletImpl::<'static, HTTPNodeClient>::new(node_client.clone()).unwrap())
            as Box<
                dyn WalletInst<
                    'static,
                    DefaultLCProvider<HTTPNodeClient, ExtKeychain>,
                    HTTPNodeClient,
                    ExtKeychain,
                >,
            >;

    // Wallet LifeCycle Provider provides all functions init wallet and work with seeds, etc...
    let lc = wallet.lc_provider().unwrap();

    // The top level wallet directory should be set manually (in the reference implementation,
    // this is provided in the WalletConfig)
    let _ = lc.set_top_level_directory(&wallet_config.data_file_dir);

    // Wallet must be opened with the password (TBD)
    let pw = ZeroingString::from("wallet_password");
    let _ = lc.open_wallet(None, pw, false, false, None);

    // All wallet functions operate on an Arc::Mutex to allow multithreading where needed
    let wallet = Arc::new(Mutex::new(wallet));
    let dir = "./.mwc";

    let api_owner = Owner::new(wallet.clone(), None, None);
    let _ = api_owner.set_top_level_directory(dir);

    // Create configuration
    let _ = api_owner.create_config(&global::ChainTypes::Mainnet, None, None, None, None);

    // create new wallet wirh random seed
    let pw = ZeroingString::from("my_password");
    let _ = api_owner.create_wallet(None, None, 0, pw.clone(), None);
    let res = api_owner.open_wallet(None, pw, true, None);

    if let Ok(m) = res {
        // Just address at derivation index 0 for now
        let mqs_pub_key = api_owner.get_mqs_address(m.as_ref()).unwrap();
        let tor_pub_key = api_owner.get_wallet_public_address(m.as_ref()).unwrap();

        let mqs_addr = ProvableAddress::from_pub_key(&mqs_pub_key);
        let tor_addr = ProvableAddress::from_tor_pub_key(&tor_pub_key);

        println!("MQS public address:       {}", mqs_addr);
        println!("Tor/SlatepackTor address: {}", tor_addr);
        println!();
        println!("Hello, world!");
    }
}

// pub fn seed_exists(config: &WalletConfig) -> bool {
//     match config.get_data_path_str() {
//         Ok(path) => WalletSeed::seed_file_exists(&path).unwrap_or(false),
//         _ => false,
//     }
// }

// pub fn create_wallet_config(config: Config) -> Result<WalletConfig, Error> {
//     let chain_type = match config.chain.as_ref() {
//         "mainnet" => ChainTypes::Mainnet,
//         "floonet" => ChainTypes::Floonet,
//         "usertesting" => ChainTypes::UserTesting,
//         "automatedtesting" => ChainTypes::AutomatedTesting,
//         _ => ChainTypes::Floonet,
//     };

//     let mut wallet_config = WalletConfig::default();
//     wallet_config.chain_type = Some(chain_type);
//     wallet_config.check_node_api_http_addr = config.check_node_api_http_addr;
//     wallet_config.data_file_dir = config.data_file_dir;

//     Ok(wallet_config)
// }

// pub fn init_wallet(config_json: &str) {
//     let config: Config = serde_json::from_str(&config_json).unwrap();
//     let wallet = get_wallet(&config)?;
// }

// pub fn get_wallet(config: &Config) -> Result<Wallet, Error> {
//     let wallet_config = create_wallet_config(config.clone())?;
//     let target_chaintype = wallet_config.chain_type.unwrap_or(ChainTypes::Mainnet);

//     if !global::GLOBAL_CHAIN_TYPE.is_init() {
//         global::init_global_chain_type(target_chaintype)
//     };

//     if global::get_chain_type() != target_chaintype {
//         global::set_local_chain_type(target_chaintype);
//     };

//     return Ok(wallet);
// }

// pub fn open_wallet() {}

// pub fn close_wallet(wallet: &Wallet) -> Result<(), Error> {
//     let mut wallet_lock = wallet.lock();
//     let lc = wallet_lock.lc_provider()?;
//     if let Ok(open_wallet) = lc.wallet_exists(None) {
//         if open_wallet {
//             lc.close_wallet(None)?;
//         }
//     }

//     Ok(())
// }

// pub fn get_wallet_address(wallet: &Wallet) {
//     let api_owner = Owner::new(wallet.clone(), None, None);
//     let mqs_pub_key = api_owner.get_mqs_address(m.as_ref()).unwrap();
//     let tor_pub_key = api_owner.get_wallet_public_address(m.as_ref()).unwrap();

//     let mqs_addr = ProvableAddress::from_pub_key(&mqs_pub_key);
//     let tor_addr = ProvableAddress::from_tor_pub_key(&tor_pub_key);

//     println!("MQS public address:       {}", mqs_addr);
//     println!("Tor/SlatepackTor address: {}", tor_addr);
//     println!();
//     println!("Hello, world!");
// }

// pub fn get_wallet_phrase() {}
